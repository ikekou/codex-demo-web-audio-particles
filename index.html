<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Audio Reactive Particles</title>
    <style>
      /* Layout */
      html, body {
        margin: 0;
        height: 100%;
        background: #0a0a0a;
        color: #eaeaea;
        font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Inter,
          Helvetica, Arial, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
      }
      #app {
        position: relative;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      canvas {
        display: block;
        width: 100%;
        height: 100%;
        background: radial-gradient(1200px 800px at 20% 10%, #111 0%, #0a0a0a 60%, #070707 100%);
      }

      /* Controls */
      .controls {
        position: absolute;
        left: 12px;
        right: 12px;
        bottom: 12px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
        pointer-events: none; /* allow canvas interactions; enable per control */
      }
      .panel {
        pointer-events: auto;
        background: rgba(18, 18, 18, 0.7);
        backdrop-filter: blur(6px);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 10px;
        padding: 10px 12px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
      }
      .row {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
      }
      .grow {
        flex: 1 1 auto;
      }
      .label {
        font-size: 12px;
        color: #bbb;
        width: 90px;
      }
      button, input[type="range"], input[type="checkbox"] {
        -webkit-tap-highlight-color: transparent;
      }
      button {
        appearance: none;
        border: 1px solid rgba(255, 255, 255, 0.15);
        background: linear-gradient(180deg, #2a2a2a, #1d1d1d);
        color: #f0f0f0;
        border-radius: 8px;
        padding: 8px 12px;
        font-size: 14px;
        cursor: pointer;
        transition: transform 0.06s ease, background 0.2s ease;
      }
      button:hover { transform: translateY(-1px); }
      button:active { transform: translateY(0); }
      button[disabled] { opacity: 0.5; cursor: not-allowed; }

      input[type="range"] {
        width: 100%;
      }
      .meta {
        font-size: 12px;
        color: #9aa0a6;
      }
      .badge {
        display: inline-block;
        padding: 2px 6px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.12);
        font-size: 11px;
        margin-left: 8px;
      }

      @media (min-width: 720px) {
        .controls { left: 16px; right: auto; width: 420px; }
      }
    </style>
  </head>
  <body>
    <div id="app">
      <canvas id="canvas"></canvas>
      <div class="controls">
        <div class="panel">
          <div class="row" style="justify-content: space-between">
            <div>
              <strong>Audio Particles</strong>
              <span id="modeBadge" class="badge">idle</span>
            </div>
            <div class="meta" id="readout">vol: 0.00 freq: 0Hz</div>
          </div>
          <div class="row">
            <button id="startBtn">開始</button>
            <button id="stopBtn" disabled>停止</button>
            <button id="shotBtn" class="grow">スクリーンショット保存</button>
          </div>
          <div class="row">
            <span class="label">粒子数</span>
            <input id="countInput" type="range" min="50" max="1500" step="10" value="500" />
            <span id="countLabel" class="meta"></span>
          </div>
          <div class="row">
            <span class="label">トレイル</span>
            <input id="trailInput" type="range" min="0" max="100" step="1" value="60" />
            <span id="trailLabel" class="meta"></span>
          </div>
        </div>
      </div>
    </div>

    <script>
      // ----- Types & Global State ----------------------------------------------------
      /** @typedef {{x:number,y:number,px:number,py:number,vx:number,vy:number,size:number,h:number}} Particle */

      const state = {
        running: false,
        usingDemo: false,
        particles: /** @type {Particle[]} */ ([]),
        particleCount: 500,
        width: 0,
        height: 0,
        dpr: 1,
        trail: 0.6, // 0..1 (trail length: higher = longer)
        lastTime: 0,
        rafId: 0,
        // audio
        audioCtx: /** @type {AudioContext|null} */ (null),
        analyser: /** @type {AnalyserNode|null} */ (null),
        sourceNode: /** @type {MediaStreamAudioSourceNode|AudioNode|null} */ (null),
        demoNodes: /** @type {{osc?: OscillatorNode, noise?: AudioBufferSourceNode, gain?: GainNode}|null} */ (null),
        freqData: /** @type {Uint8Array|null} */ (null),
        timeData: /** @type {Uint8Array|null} */ (null),
        features: /** @type {{volume:number,bass:number,mid:number,treble:number,centroid:number,peakHz:number,attack:boolean}|null} */ (null),
        _ema: /** @type {{vol?:number,bass?:number,mid?:number,treble?:number}|} */ ({}),
      };

      // ----- Utility Functions -------------------------------------------------------
      /** Clamp value to [min, max] */
      function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }
      /** Linear map v from [a,b] to [c,d] */
      function map(v, a, b, c, d) { return c + ((v - a) * (d - c)) / (b - a); }
      /** Random float in [min, max) */
      function rand(min, max) { return min + Math.random() * (max - min); }

      // ----- Canvas Setup & Resize ---------------------------------------------------
      function resizeCanvas() {
        const canvas = document.getElementById('canvas');
        const rect = canvas.getBoundingClientRect();
        const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        state.dpr = dpr;
        state.width = Math.floor(rect.width * dpr);
        state.height = Math.floor(rect.height * dpr);
        canvas.width = state.width;
        canvas.height = state.height;
      }

      // ----- Particles ---------------------------------------------------------------
      function initParticles(count) {
        state.particles.length = 0;
        for (let i = 0; i < count; i++) state.particles.push(makeParticle());
      }

      function adjustParticleCount(count) {
        const cur = state.particles.length;
        if (count > cur) {
          for (let i = 0; i < count - cur; i++) state.particles.push(makeParticle());
        } else if (count < cur) {
          state.particles.length = count;
        }
      }

      function makeParticle() {
        const angle = rand(0, Math.PI * 2);
        const speed = rand(0.1, 0.6);
        const x = rand(0, state.width);
        const y = rand(0, state.height);
        return {
          x,
          y,
          px: x,
          py: y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          size: rand(0.8, 2.8) * (state.dpr || 1),
          h: rand(0, 360),
        };
      }

      function updateParticles(dt, features) {
        const { volume, bass, mid, treble, centroid, peakHz, attack } = features;
        const speedBoost = 0.8 + mid * 3.2 + (attack ? 0.6 : 0); // mid drives overall speed, attacks kick
        const hueBase = ((centroid || peakHz) % 1200) / 1200; // centroid-driven hue band
        const centerX = state.width * 0.5;
        const centerY = state.height * 0.5;
        const attract = map(bass, 0, 1, -0.03, 0.16); // bass pulls to center
        const swirl = map(treble, 0, 1, 0.0, 0.06); // treble adds curl
        const jitterBase = map(treble, 0, 1, 0.0, 0.35);
        const maxV = 3.6 * state.dpr + bass * 2.0 * state.dpr;

        for (let i = 0; i < state.particles.length; i++) {
          const p = state.particles[i];
          p.px = p.x;
          p.py = p.y;
          // Gentle attraction/repulsion relative to center influenced by dominant frequency.
          const dx = centerX - p.x;
          const dy = centerY - p.y;
          const dist = Math.hypot(dx, dy) + 1e-4;
          const nx = dx / dist;
          const ny = dy / dist;
          p.vx += nx * attract * (0.5 + hueBase);
          p.vy += ny * attract * (0.5 + (1 - hueBase));

          // Curl/swirl field + jitter influenced by treble energy.
          const curl = swirl;
          const a = Math.sin((p.x + p.y) * 0.002 + i * 0.017);
          p.vx += (-ny) * curl + Math.cos(a) * jitterBase;
          p.vy += (nx) * curl + Math.sin(a) * jitterBase;

          // Limit speed and apply energy scaling.
          const vlen = Math.hypot(p.vx, p.vy) + 1e-4;
          const scale = Math.min(maxV, vlen * speedBoost) / vlen;
          p.vx *= scale;
          p.vy *= scale;

          // Integrate
          p.x += p.vx * dt;
          p.y += p.vy * dt;

          // Wrap edges and avoid long jump trails
          let wrapped = false;
          if (p.x < -10) { p.x = state.width + 10; wrapped = true; }
          if (p.x > state.width + 10) { p.x = -10; wrapped = true; }
          if (p.y < -10) { p.y = state.height + 10; wrapped = true; }
          if (p.y > state.height + 10) { p.y = -10; wrapped = true; }
          if (wrapped) { p.px = p.x; p.py = p.y; }

          // Color hue reacts to spectral centroid; brightness will be set in draw
          p.h = (hueBase * 360 + i * 0.2) % 360;
          // Size breathes with bass
          p.size = clamp(p.size * (0.98 + bass * 0.06 + (attack ? 0.06 : 0)), 0.6 * state.dpr, 5.0 * state.dpr);
        }
      }

      function drawParticles(ctx, features) {
        const { volume, bass, mid, treble, attack } = features;
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        const glow = clamp(0.25 + volume * 0.9 + (attack ? 0.2 : 0), 0.2, 1.3);
        const lineW = (0.5 + bass * 2.0) * state.dpr;
        for (let i = 0; i < state.particles.length; i++) {
          const p = state.particles[i];
          // Trail line from previous position to current (skip if jump is too large)
          const dx = p.x - p.px;
          const dy = p.y - p.py;
          const jump = Math.hypot(dx, dy);
          const jumpLimit = Math.min(state.width, state.height) * 0.25;
          if (jump < jumpLimit) {
            ctx.strokeStyle = `hsla(${p.h}, 90%, ${clamp(55 + treble * 30, 55, 85)}%, ${clamp(0.25 + mid * 0.6, 0.2, 0.9)})`;
            ctx.lineWidth = lineW;
            ctx.beginPath();
            ctx.moveTo(p.px, p.py);
            ctx.lineTo(p.x, p.y);
            ctx.stroke();
          } else {
            // Reset previous to avoid drawing a cross-screen line
            p.px = p.x; p.py = p.y;
          }
          // Particle core
          ctx.fillStyle = `hsl(${p.h}, 85%, ${clamp(50 + volume * 25, 50, 75)}%)`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size * glow, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      // ----- Audio Setup -------------------------------------------------------------
      async function setupAudio() {
        // Create context lazily due to mobile autoplay policies.
        const ctx = new (window.AudioContext || window.webkitAudioContext)({
          latencyHint: 'interactive',
        });
        const analyser = ctx.createAnalyser();
        analyser.fftSize = 2048;
        analyser.smoothingTimeConstant = 0.8;
        analyser.minDecibels = -90;
        analyser.maxDecibels = -10;
        const freqData = new Uint8Array(analyser.frequencyBinCount);
        const timeData = new Uint8Array(analyser.fftSize);

        let source = null;
        let usingDemo = false;
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          source = ctx.createMediaStreamSource(stream);
        } catch (err) {
          // Fallback: demo oscillator + noise blend for environments without mic or when denied.
          usingDemo = true;
          const { srcNode, nodes } = createDemoAudioSource(ctx);
          source = srcNode;
          state.demoNodes = nodes;
        }

        source.connect(analyser);

        state.audioCtx = ctx;
        state.analyser = analyser;
        state.sourceNode = source;
        state.freqData = freqData;
        state.timeData = timeData;
        state.usingDemo = usingDemo;
        updateModeBadge();
      }

      function createDemoAudioSource(ctx) {
        // Create a musical-like demo signal: oscillator sweeping + subtle noise bed.
        const osc = ctx.createOscillator();
        osc.type = 'sawtooth';
        const noiseBuf = ctx.createBuffer(1, ctx.sampleRate * 2, ctx.sampleRate);
        const data = noiseBuf.getChannelData(0);
        for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * 0.35;
        const noise = ctx.createBufferSource();
        noise.buffer = noiseBuf;
        noise.loop = true;

        const mix = ctx.createGain();
        const oscGain = ctx.createGain();
        const noiseGain = ctx.createGain();
        oscGain.gain.value = 0.6;
        noiseGain.gain.value = 0.2;

        // Sweep frequency slowly for visual diversity.
        const now = ctx.currentTime;
        osc.frequency.setValueAtTime(120, now);
        osc.frequency.linearRampToValueAtTime(880, now + 4.5);
        osc.frequency.linearRampToValueAtTime(220, now + 9);
        // Loop sweep using automation by rescheduling periodically.
        setInterval(() => {
          const t = ctx.currentTime;
          osc.frequency.cancelScheduledValues(t);
          osc.frequency.setValueAtTime(200, t);
          osc.frequency.exponentialRampToValueAtTime(900, t + 3.6);
          osc.frequency.exponentialRampToValueAtTime(180, t + 7.2);
        }, 7000);

        osc.connect(oscGain).connect(mix);
        noise.connect(noiseGain).connect(mix);

        osc.start();
        noise.start();
        return { srcNode: mix, nodes: { osc, noise, gain: mix } };
      }

      function stopAudio() {
        if (state.audioCtx) {
          // Stop mic tracks if any
          try {
            const src = state.sourceNode;
            if (src && src.mediaStream) {
              src.mediaStream.getTracks().forEach(t => t.stop());
            }
          } catch (_) {}

          // Stop demo nodes if used
          if (state.demoNodes) {
            try { state.demoNodes.osc && state.demoNodes.osc.stop(); } catch (_) {}
            try { state.demoNodes.noise && state.demoNodes.noise.stop(); } catch (_) {}
            state.demoNodes = null;
          }

          try { state.audioCtx.close(); } catch (_) {}
        }
        state.audioCtx = null;
        state.analyser = null;
        state.sourceNode = null;
      }

      // ----- Audio Analysis ----------------------------------------------------------
      function analyzeAudio() {
        const analyser = state.analyser;
        if (!analyser || !state.freqData || !state.timeData || !state.audioCtx)
          return { volume: 0, bass: 0, mid: 0, treble: 0, centroid: 0, peakHz: 0, attack: false };

        analyser.getByteFrequencyData(state.freqData);
        analyser.getByteTimeDomainData(state.timeData);

        // Volume estimate: RMS of time domain, normalized with mild gain.
        let sum = 0;
        for (let i = 0; i < state.timeData.length; i++) {
          const v = (state.timeData[i] - 128) / 128;
          sum += v * v;
        }
        const rms = Math.sqrt(sum / state.timeData.length);
        let volume = clamp(rms * 2.2, 0, 1);

        // Band energies
        const fs = state.audioCtx.sampleRate;
        const fftSize = analyser.fftSize;
        const binToHz = (bin) => (bin * fs) / fftSize;
        const hzToBin = (hz) => Math.round((hz * fftSize) / fs);

        const bassRange = [20, 140];
        const midRange = [140, 2000];
        const treRange = [2000, Math.min(8000, fs / 2)];
        function bandEnergy(hz0, hz1) {
          const i0 = clamp(hzToBin(hz0), 1, state.freqData.length - 1);
          const i1 = clamp(hzToBin(hz1), 1, state.freqData.length - 1);
          let s = 0;
          let c = 0;
          for (let i = Math.min(i0, i1); i <= Math.max(i0, i1); i++) { s += state.freqData[i]; c++; }
          return c ? (s / (c * 255)) : 0;
        }
        let bass = bandEnergy(...bassRange);
        let mid = bandEnergy(...midRange);
        let treble = bandEnergy(...treRange);

        // Spectral centroid and peak frequency
        let num = 0, den = 0, maxVal = -1, maxIdx = 0;
        for (let i = 1; i < state.freqData.length; i++) {
          const mag = state.freqData[i] / 255;
          const hz = binToHz(i);
          num += mag * hz;
          den += mag;
          if (state.freqData[i] > maxVal) { maxVal = state.freqData[i]; maxIdx = i; }
        }
        const centroid = den > 0 ? num / den : 0;
        const peakHz = binToHz(maxIdx);

        // EMAs for smoother control
        const a = 0.15; // smoothing factor
        state._ema.vol = state._ema.vol == null ? volume : (1 - a) * state._ema.vol + a * volume;
        state._ema.bass = state._ema.bass == null ? bass : (1 - a) * state._ema.bass + a * bass;
        state._ema.mid = state._ema.mid == null ? mid : (1 - a) * state._ema.mid + a * mid;
        state._ema.treble = state._ema.treble == null ? treble : (1 - a) * state._ema.treble + a * treble;

        volume = state._ema.vol;
        bass = state._ema.bass;
        mid = state._ema.mid;
        treble = state._ema.treble;

        // Attack detection
        const attack = (volume - (state._prevVol || 0)) > 0.06;
        state._prevVol = volume;

        return { volume, bass, mid, treble, centroid, peakHz, attack };
      }

      // ----- Render Loop -------------------------------------------------------------
      function drawFrame(ts) {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const dt = state.lastTime ? Math.min(50, ts - state.lastTime) : 16;
        state.lastTime = ts;

        const features = analyzeAudio();
        state.features = features;
        updateReadout(features);

        // Fade for trails: slider represents persistence (longer to the right)
        // Map length (0..1) -> fade alpha (0.02..0.95) with slight gamma for feel
        const fade = clamp(0.02 + 0.93 * (1 - Math.pow(state.trail, 0.7)), 0.02, 0.95);
        ctx.fillStyle = `rgba(10,10,10,${fade})`;
        ctx.fillRect(0, 0, state.width, state.height);

        updateParticles(dt * 0.06, features);
        drawParticles(ctx, features);

        if (state.running) state.rafId = requestAnimationFrame(drawFrame);
      }

      // ----- UI Handling -------------------------------------------------------------
      async function handleStart() {
        if (state.running) return;
        await setupAudio();
        if (!state.audioCtx) return;
        try { await state.audioCtx.resume(); } catch (_) {}

        state.running = true;
        state.lastTime = 0;
        document.getElementById('startBtn').disabled = true;
        document.getElementById('stopBtn').disabled = false;
        state.rafId = requestAnimationFrame(drawFrame);
      }

      function handleStop() {
        if (!state.running) return;
        state.running = false;
        cancelAnimationFrame(state.rafId);
        state.lastTime = 0;
        document.getElementById('startBtn').disabled = false;
        document.getElementById('stopBtn').disabled = true;
        stopAudio();
        updateModeBadge();
      }

      function handleShot() {
        const canvas = document.getElementById('canvas');
        const url = canvas.toDataURL('image/png');
        const a = document.createElement('a');
        const ts = new Date().toISOString().replace(/[:.]/g, '-');
        a.href = url;
        a.download = `particles-${ts}.png`;
        document.body.appendChild(a);
        a.click();
        a.remove();
      }

      function updateModeBadge() {
        const badge = document.getElementById('modeBadge');
        if (state.running) {
          badge.textContent = state.usingDemo ? 'demo' : 'mic';
        } else {
          badge.textContent = 'idle';
        }
      }

      function updateReadout(features) {
        const ro = document.getElementById('readout');
        const f0 = Math.round(features.peakHz || features.centroid || 0);
        ro.textContent = `vol: ${features.volume.toFixed(2)} b:${features.bass.toFixed(2)} m:${features.mid.toFixed(2)} t:${features.treble.toFixed(2)} ${f0}Hz`;
      }

      function bindUI() {
        const countInput = document.getElementById('countInput');
        const countLabel = document.getElementById('countLabel');
        const trailInput = document.getElementById('trailInput');
        const trailLabel = document.getElementById('trailLabel');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const shotBtn = document.getElementById('shotBtn');

        function refreshLabels() {
          countLabel.textContent = `${state.particleCount}`;
          trailLabel.textContent = `${Math.round(state.trail * 100)}%`;
        }

        // Particle count
        countInput.addEventListener('input', (e) => {
          const v = parseInt(e.target.value, 10) || state.particleCount;
          state.particleCount = clamp(v, 50, 1500);
          adjustParticleCount(state.particleCount);
          refreshLabels();
        });

        // Trail length (0..1): higher = longer persistence
        trailInput.addEventListener('input', (e) => {
          const percent = parseInt(e.target.value, 10) || 0;
          state.trail = clamp(percent / 100, 0, 1);
          refreshLabels();
        });

        startBtn.addEventListener('click', handleStart);
        stopBtn.addEventListener('click', handleStop);
        shotBtn.addEventListener('click', handleShot);

        refreshLabels();
      }

      function setup() {
        resizeCanvas();
        initParticles(state.particleCount);
        bindUI();
        updateModeBadge();
        window.addEventListener('resize', () => {
          const wasRunning = state.running;
          if (wasRunning) cancelAnimationFrame(state.rafId);
          resizeCanvas();
          // Keep particle distribution consistent across DPI/size changes.
          adjustParticleCount(state.particleCount);
          // Reset previous positions to avoid long lines after resize
          for (const p of state.particles) { p.px = p.x; p.py = p.y; }
          if (wasRunning) state.rafId = requestAnimationFrame(drawFrame);
        });
      }

      // Initialize after DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setup);
      } else {
        setup();
      }
    </script>
  </body>
  </html>
